const prettier = require('prettier')
const util = require('./util')
const { VariableType } = require('./enum')

const empty = `// No HTTP/HTTPS transactions have been recorded`
const staticImports = [ './postman-shim.js' ]

function render (result) {
  if (!result.main.length) {
    return empty
  }
  const raw = [
    header(),
    imports(result),
    options(result),
    data(result),
    initial(result),
    logic(result)
  ].filter(section => section).join(`\n\n`)
  return prettier.format(raw, { semi: true, parser: 'babel' })
}

function header () {
  return `// Auto-generated by the Load Impact converter`
}

function imports (result) {
  const direct = []
  const indirect = {}
  for (const [ name, spec ] of result.imports) {
    if (typeof spec === 'object') {
      const { base } = spec
      if (!(base in indirect)) {
        indirect[base] = []
      }
      indirect[base].push(name)
    } else {
      direct.push([ name, spec ])
    }
  }
  const lines = []
  for (const path of staticImports) {
    lines.push(staticImport(path))
  }
  for (const [ name, path ] of direct) {
    lines.push(imp(name, path))
  }
  for (const key of Object.keys(indirect)) {
    const name = `{ ${indirect[key].join(`, `)} }`
    lines.push(imp(name, key))
  }
  return lines.join(`\n`)
}

function staticImport (path) {
  return `import ${JSON.stringify(path)};`
}

function imp (name, path) {
  return `import ${name} from ${JSON.stringify(path)};`
}

function options (result) {
  if (result.iterations > 1) {
    result.options.iterations = result.iterations
  }
  if (!Object.keys(result.options).length) {
    return null
  }
  return `export let options = ${JSON.stringify(result.options)};`
}

function data (result) {
  if (!result.data.path) {
    return null
  }
  const parse = dataParse(result)
  const sections = []
  sections.push(`const file = (() => {
  // Load data file
  const text = open(${JSON.stringify(result.data.path)});
  const rows = ${parse};
  return rows;
})();`)
  if (result.iterations === null) {
    sections.push(`options.iterations = file.length;`)
  }
  return sections.join(`\n`)
}

function dataParse (result) {
  switch (result.data.type) {
    case 'csv':
      return `papaparse.parse(text, { header: true }).data`
    case 'json':
      return `JSON.parse(text)`
    default:
      throw new Error(`Unrecognized data file type: ${result.data.type}`)
  }
}

function initial (result) {
  const lines = []
  if (iterationMessage(result)) {
    lines.push(`const Iteration = Symbol.for("iteration");`)
  }
  for (const [ name, label ] of result.symbols) {
    lines.push(`const ${name} = Symbol.for(${JSON.stringify(label)});`)
  }
  lines.push(`const Request = Symbol.for("request");`)
  const initial = [
    globalScope(result),
    collectionScope(result),
    environmentScope(result),
    dataScope(result),
    iterations(result)
  ].filter(item => item)
  if (initial.length) {
    const args = initialArgs(initial)
    lines.push(`postman[Symbol.for("initial")](${args});`)
  }
  return lines.join(`\n`)
}

function globalScope (result) {
  if (result.scope.global.size) {
    return `global: ${vars(result.scope.global)}`
  } else {
    return null
  }
}

function collectionScope (result) {
  if (result.scope.collection.size) {
    return `collection: ${vars(result.scope.collection)}`
  } else {
    return null
  }
}

function environmentScope (result) {
  if (result.scope.environment.size) {
    return `environment: ${vars(result.scope.environment)}`
  } else {
    return null
  }
}

function dataScope (result) {
  if (result.data.path) {
    return `data: file`
  } else {
    return null
  }
}

function iterations (result) {
  if (result.iterations > 1) {
    return `iterations: ${result.iterations}`
  } else {
    return null
  }
}

function initialArgs (initial) {
  if (initial.length) {
    return `{
${util.indent(initial.join(`,\n`))}
}`
  } else {
    return ``
  }
}

function vars (spec) {
  const items = []
  for (const item of spec) {
    if (item[1] === undefined) {
      continue
    }
    const name = JSON.stringify(item[0])
    const value = varValue(item[1])
    items.push(`${name}: ${value}`)
  }
  return `{
${util.indent(items.join(`,\n`))}
}`
}

function varValue (spec) {
  switch (spec.type) {
    case VariableType.Boolean:
    case VariableType.Number:
    case VariableType.Literal:
      return spec.value
    case VariableType.Json:
    case VariableType.String:
      return JSON.stringify(spec.value)
    default:
      throw new Error(`Unrecognized variable type: ${spec.type}`)
  }
}

function logic (result) {
  return `export default function() {
${util.indent(outer(result))}
}
`
}

function outer (result) {
  return [
    declares(result),
    iteration(result),
    enter(result),
    main(result),
    exit(result)
  ].filter(section => section).join(`\n\n`)
}

function body (spec) {
  return [
    declares(spec),
    enter(spec),
    main(spec),
    exit(spec)
  ].filter(section => section).join(`\n\n`)
}

function declares (spec) {
  if (!spec.declares.size) {
    return null
  }
  return `let ${[ ...spec.declares ].join(`, `)};`
}

function enter (spec) {
  const sections = []
  if (spec.pre) {
    sections.push(`postman[Pre].push(() => {
${util.indent(spec.pre)}
});`)
  }
  if (spec.post) {
    sections.push(`postman[Post].push(() => {
${util.indent(spec.post)}
});`)
  }
  if (sections.length) {
    return sections.join(`\n`)
  } else {
    return null
  }
}

function exit (spec) {
  const sections = []
  if (spec.pre) {
    sections.push(`postman[Pre].pop();`)
  }
  if (spec.post) {
    sections.push(`postman[Post].pop();`)
  }
  if (sections.length) {
    return sections.join(`\n`)
  } else {
    return null
  }
}

function iteration (result) {
  if (iterationMessage(result)) {
    return `postman[Iteration]();`
  } else {
    return null
  }
}

function iterationMessage (result) {
  return !!result.data.path
}

function main (spec) {
  return spec.main.map(item => chunk(item)).join(`\n\n`)
}

function chunk (item) {
  if (!item) {
    return ``
  }
  const type = typeof item
  switch (type) {
    case 'string':
      return item
    case 'object':
      if (Array.isArray(item)) {
        return item.join(`\n`)
      } else {
        return group(item)
      }
    default:
      throw new Error('Invalid chunk type: ' + type)
  }
}

function group (spec) {
  return `group(${JSON.stringify(spec.name)}, function () {
${util.indent(body(spec))}
});`
}

module.exports = render
