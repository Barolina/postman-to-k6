const prettier = require('prettier')
const util = require('./util')

const empty = `// No HTTP/HTTPS transactions have been recorded`

function render (result) {
  if (!result.main.length) return empty
  const raw = [
    header(),
    imports(result),
    options(result),
    logic(result)
  ].filter(section => section).join(`\n\n`)
  return prettier.format(raw, { semi: true, parser: 'babel' })
}

function header () {
  return `// Auto-generated by the Load Impact converter`
}

function imports (result) {
  const direct = []
  const indirect = {}
  for (const [ name, spec ] of result.imports) {
    if (typeof spec === 'object') {
      const { base } = spec
      if (!(base in indirect)) indirect[base] = []
      indirect[base].push(name)
    } else direct.push([ name, spec ])
  }
  const lines = []
  for (const [ name, path ] of direct) lines.push(imp(name, path))
  for (const key of Object.keys(indirect)) {
    const name = `{ ${indirect[key].join(`, `)} }`
    lines.push(imp(name, key))
  }
  return lines.join(`\n`)
}

function imp (name, path) {
  return `import ${name} from ${JSON.stringify(path)};`
}

function options (result) {
  if (!Object.keys(result.options).length) return null
  return `export let options = ${JSON.stringify(result.options)};`
}

function logic (result) {
  return `export default function() {
${util.indent(body(result))}
}
`
}

function body (spec) {
  return [
    vars(spec),
    declares(spec),
    main(spec)
  ].filter(section => section).join(`\n\n`)
}

function vars (spec) {
  if (!spec.vars || !spec.vars.size) return null
  const items = []
  for (const item of spec.vars) {
    if (item[1] === undefined) continue
    const name = JSON.stringify(item[0])
    const value = varValue(item[1])
    items.push(`vars[${name}] = ${value}`)
  }
  return `const vars = {}
${items.join(`\n`)}`
}

function varValue (spec) {
  return JSON.stringify(spec.value)
}

function declares (spec) {
  if (!spec.declares.size) return null
  return `let ${[ ...spec.declares ].join(`, `)};`
}

function main (spec) {
  return spec.main.map(item => chunk(item)).join(`\n\n`)
}

function chunk (item) {
  if (!item) return ``
  const type = typeof item
  switch (type) {
    case 'string': return item
    case 'object':
      if (Array.isArray(item)) return item.join(`\n`)
      else return group(item)
    default: throw new Error('Invalid chunk type: ' + type)
  }
}

function group (spec) {
  return `group(${JSON.stringify(spec.name)}, function () {
${util.indent(body(spec))}
});`
}

module.exports = render
